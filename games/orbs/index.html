<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Backyard Orbs — Enoch and the Watchers (2.1 Mobile → 2.2 polish)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f14;color:#e6f0ff;font-family:Arial,Helvetica,sans-serif; overscroll-behavior: none;}
  #wrap{display:flex;flex-direction:column;height:100%}
  header{padding:10px 12px;display:flex;gap:8px;align-items:center;background:#101722;border-bottom:1px solid #243140; padding-top: calc(10px + env(safe-area-inset-top));}
  .btn{padding:10px 14px;border:1px solid #2a3a4a;background:#121a22;color:#e6f0ff;border-radius:10px;cursor:pointer}
  .btn.small{padding:6px 10px;border-radius:8px;font-size:12px}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .stat{padding:6px 8px;border:1px solid #243140;background:#0e141b;border-radius:6px;font-variant-numeric:tabular-nums; font-size: clamp(12px, 2.6vw, 14px);}
  canvas{display:block;width:100%;height:100%; touch-action: none; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none;}

  /* Start (Primer) */
  #title{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;flex-direction:column;background: linear-gradient(rgba(11,15,20,0.85), rgba(11,15,20,0.85)), url('enoch.png') center/cover no-repeat;backdrop-filter:saturate(120%) blur(2px)}
  #card{width:min(92%,780px);border:1px solid #243140;background:#0e141b;padding:16px 14px 18px;border-radius:12px;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.35)}
  #toggles{display:none} /* toggles removed */
  #card h1 { font-size: clamp(20px, 6vw, 28px); }
  .mono{font-variant-numeric:tabular-nums}
  footer{position:absolute;bottom:8px;left:50%;transform:translateX(-50%);color:#9fb6cc;font-size:12px; padding-bottom: env(safe-area-inset-bottom);}

  /* Lore / Prologue */
  #loreBox{margin:12px auto 6px;text-align:left;background:linear-gradient(180deg,#0b1219,#0c131a);border:1px solid #243140;border-radius:10px;max-width:720px}
  #loreHead{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;border-bottom:1px solid #1a2733}
  #loreHead .title{font-weight:bold;letter-spacing:.6px}
  #loreHead .b20{background:linear-gradient(90deg,#9fe2ff,#c9b3ff);-webkit-background-clip:text;background-clip:text;color:transparent}
  #loreBody{padding:10px 12px;max-height:0;overflow:hidden;transition:max-height 400ms ease}
  #loreBox.open #loreBody{max-height:240px}
  #loreBody p{margin:6px 0;color:#cfe2ff;line-height:1.35}
  #loreBody em{color:#a9c6ff}

  /* Overlay (used by win & lose) */
  #cinOverlay{position:absolute;inset:0;pointer-events:none;display:none}
  #cinOverlay .center{position:absolute;left:50%;top:78%;transform:translate(-50%,-50%);width:min(92%,820px);text-align:center}
  #cinOverlay .title{font-size:28px;letter-spacing:6px;color:#eaf4ff;text-shadow:0 0 16px rgba(150,210,255,.6);opacity:.95}
  #cinOverlay .verses{margin-top:14px;color:#eaf4ff;text-shadow:0 0 10px rgba(180,220,255,0.55);font-size:18px;line-height:1.35}
  #cinOverlay .hint{color:#9fb6cc;font-size:12px;margin-top:8px}
  #cinOverlay .btnRow{margin-top:16px;display:flex;gap:10px;justify-content:center}
  #cinOverlay .center.topRight{
    left: auto;
    right: 6%;
    top: 22%;
    transform: translate(0,-50%);
    text-align: right;
    width: min(92%, 520px);
  }
  @media (max-width: 480px){
    #cinOverlay .center.topRight{
      right: 4%;
      top: 18%;
      width: min(92%, 420px);
    }
  }

</style>
</head>
<body>
<div id="wrap">
  <header>
    <button id="startBtn" class="btn">Play</button>
    <button id="pauseBtn" class="btn" disabled>Pause</button>
    <button id="resetBtn" class="btn" disabled>Reset</button>
    <div class="stat">Score: <span id="scoreEl">0</span></div>
    <div class="stat">Time: <span id="timeEl">60.0</span>s</div>
    <div class="stat">Hits: <span id="hitsEl">0</span> Misses: <span id="missesEl">0</span></div>
    <div class="stat">Goal: <span id="goalEl">1500</span></div>
  </header>

  <!-- Primer -->
  <div id="title">
    <div id="card">
      <h1 style="margin:6px 0 4px;">Backyard Orbs</h1>
      <p style="margin:6px 0 10px;color:#cfe6ff"><em>Night watch. Signs in the heavens.</em></p>

      <!-- Lore / Prologue (collapsed by default) -->
      <div id="loreBox" class="">
        <div id="loreHead">
          <div class="title">Prologue: <span class="b20">Enoch and the Watchers</span></div>
          <button id="loreToggle" class="btn small">Read</button>
        </div>
        <div id="loreBody">
          <p>Tonight the luminaries stir—stars sliding like messengers. Not burning rocks, but living lights. Yet <em>something</em> is watching the watchers.</p>
          <p>Use your backyard beam to identify the light sources and unlock their messages. <span style="color:#9fe2ff">Blue orbs</span> answer truth; <span style="color:#ff9aa0">red drones</span> spoof and interfere.</p>
          <p>Beware the watching AI-drones—they do not want the mysteries of <strong>Enoch and the Watchers</strong> exposed. Gather truth before dawn and you may see the Heavens speak.</p>
        </div>
      </div>

      <p style="margin:6px 0 6px">
        <span style="color:#9fe2ff">Blue orbs</span> are living lights — keepers of truth.<br>
        <span style="color:#ff9aa0">Red drones</span> are deceivers — fallen watchers and their toys.
      </p>
      <p style="margin:0 0 10px">Shine your beam, gather truth, avoid the counterfeit. Reach <strong>1500</strong> before dawn.</p>

      <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin:10px 0 8px" class="mono">
        <span class="stat">Aim: mouse/touch</span>
        <span class="stat">Beam: hold</span>
      </div>
      <p style="margin:0 0 10px;color:#9fb6cc;font-size:12px">Hint: Streaks awaken the heavens to speak.</p>

      <button id="tPlay" class="btn" style="min-width:220px;margin-top:6px">Start Night Watch</button>
      <!-- Toggles removed for 2.2; defaults handled in JS -->
    </div>
  </div>

  <canvas id="game"></canvas>

  <!-- Cinematic overlay UI (titles + lines + play again) -->
  <div id="cinOverlay">
    <div class="center">
      <div id="cinTitle" class="title">ENOCH</div>
      <div id="verses" class="verses"></div>
      <div class="hint" id="cinHint">Tap or press any key to continue…</div>
      <div class="btnRow"><button id="againBtn" class="btn" style="pointer-events:auto;display:none">Play Again</button></div>
    </div>
  </div>
</div>
<footer>Tip: hard-refresh (Ctrl+F5) if audio or input seems stuck.</footer>

<script>
/*
  Backyard Orbs — 2.1 Mobile (2.2 polish: UI cleanup)
  Change: Removed Sound/Reduced Motion toggles from start screen.
  Defaults are now set in code; reduced motion still auto-enables on tiny screens.
*/
(function(){
  // ===== canvas & utils =====
  const canvas=document.getElementById('game'), ctx=canvas.getContext('2d');
  const DPR=()=>window.devicePixelRatio||1;
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const rand=(a,b)=>a+Math.random()*(b-a);
  const lerp=(a,b,t)=>a+(b-a)*t;
  const easeInOut=(t)=>t<.5?2*t*t:1-Math.pow(-2*t+2,2)/2;
  function resize(){const d=DPR();canvas.width=Math.floor(canvas.clientWidth*d);canvas.height=Math.floor(canvas.clientHeight*d);ctx.setTransform(d,0,0,d,0,0)}
  new ResizeObserver(resize).observe(canvas); resize();
  const lerpColor=(c1,c2,t)=>[Math.round(lerp(c1[0],c2[0],t)),Math.round(lerp(c1[1],c2[1],t)),Math.round(lerp(c1[2],c2[2],t))];

  // ===== UI =====
  const titleEl=document.getElementById('title');
  const startBtn=document.getElementById('startBtn'), tPlay=document.getElementById('tPlay');
  const pauseBtn=document.getElementById('pauseBtn'), resetBtn=document.getElementById('resetBtn');
  const scoreEl=document.getElementById('scoreEl'), timeEl=document.getElementById('timeEl');
  const hitsEl=document.getElementById('hitsEl'), missesEl=document.getElementById('missesEl'), goalEl=document.getElementById('goalEl');
  const overlay=document.getElementById('cinOverlay'), titleText=document.getElementById('cinTitle'), versesBox=document.getElementById('verses'), againBtn=document.getElementById('againBtn'), hintEl=document.getElementById('cinHint');
  const overlayCenter = overlay.querySelector('.center');

  // Lore toggle
  const loreBox=document.getElementById('loreBox');
  const loreToggle=document.getElementById('loreToggle');
  loreToggle?.addEventListener('click',()=>{
    const open=loreBox.classList.toggle('open');
    loreToggle.textContent=open?'Hide':'Read';
  });

  // ===== defaults (toggles removed) =====
  let SFX_ENABLED=true;
  let REDUCED_MOTION=false;

  // Auto-reduced motion on small screens
  const isSmallScreen = Math.min(window.innerWidth, window.innerHeight) < 420;
  if (isSmallScreen) REDUCED_MOTION = true;

  // ===== audio =====
  let actx; const audio=()=>actx||(actx=new (window.AudioContext||window.webkitAudioContext)());
  const tone=(f=440,d=.12,t='sine',v=.15)=>{if(!SFX_ENABLED) return; const a=audio(),o=a.createOscillator(),g=a.createGain();o.type=t;o.frequency.value=f;g.gain.value=v;o.connect(g).connect(a.destination);const T=a.currentTime;o.start(T);g.gain.exponentialRampToValueAtTime(1e-4,T+d);o.stop(T+d+.02)};
  const chirp=(a,b,d)=>{if(!SFX_ENABLED) return; const A=audio(),o=A.createOscillator(),g=A.createGain();o.type='triangle';o.frequency.setValueAtTime(a,A.currentTime);o.frequency.exponentialRampToValueAtTime(b,A.currentTime+d);g.gain.value=.15;o.connect(g).connect(A.destination);o.start();g.gain.exponentialRampToValueAtTime(1e-4,A.currentTime+d);o.stop(A.currentTime+d+.01)};
  const sfx={
    orb:()=>chirp(900,1500,.12),
    drone:()=>tone(180,.18,'sawtooth',.18),
    bark:()=>{tone(450,.06,'square',.22);setTimeout(()=>tone(300,.08,'square',.2),70)},
    win:()=>{chirp(600,1600,.2);setTimeout(()=>chirp(700,1800,.25),150);setTimeout(()=>tone(1200,.25,'sine',.12),350)},
    lose:()=>{tone(110,.18,'sawtooth',.2);setTimeout(()=>tone(80,.22,'sawtooth',.22),140)}
  };

  // ===== game state =====
  const SETTINGS={timeStart:60,goal:1500,max:20,droneChance:.35};
  const STATE={running:false,paused:false,ended:false,timeLeft:SETTINGS.timeStart,score:0,hits:0,misses:0,streak:0,last:0,t:0,mode:'play'};
  goalEl.textContent=SETTINGS.goal;

  // ===== input =====
  const input={left:false,right:false,aiming:false,pointer:{x:0,y:0}};

  // Mouse input
  canvas.addEventListener('mousemove',e=>{const r=canvas.getBoundingClientRect();input.pointer.x=e.clientX-r.left;input.pointer.y=e.clientY-r.top});
  canvas.addEventListener('mousedown',()=>input.aiming=true);
  canvas.addEventListener('mouseup',()=>input.aiming=false);

  // --- TOUCH INPUT (mirrors mouse, prevents scroll/gestures) ---
  function touchPoint(e){
    const t = e.touches?.[0] || e.changedTouches?.[0];
    const r = canvas.getBoundingClientRect();
    return { x: t.clientX - r.left, y: t.clientY - r.top };
  }
  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    const p = touchPoint(e);
    input.pointer.x = p.x; input.pointer.y = p.y;
    input.aiming = true;
  }, { passive: false });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const p = touchPoint(e);
    input.pointer.x = p.x; input.pointer.y = p.y;
  }, { passive: false });

  canvas.addEventListener('touchend', (e) => {
    e.preventDefault();
    input.aiming = false;
  }, { passive: false });

  function setKey(e,d){const k=e.key.toLowerCase(); if(k==='a'||k==='arrowleft')input.left=d; if(k==='d'||k==='arrowright')input.right=d; if(k===' '&&STATE.running && STATE.mode==='play')togglePause();}
  addEventListener('keydown',e=>setKey(e,true)); addEventListener('keyup',e=>setKey(e,false));

  // ===== helpers =====
  function glowCircle(ctx,x,y,r,iA,oA,t){ctx.save();ctx.globalCompositeOperation='lighter';const g=ctx.createRadialGradient(x,y,r*.1,x,y,r);g.addColorStop(0,`rgba(${t[0]},${t[1]},${t[2]},${iA})`);g.addColorStop(1,`rgba(${t[0]},${t[1]},${t[2]},${oA})`);ctx.fillStyle=g;ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.fill();ctx.restore()}

  // ===== background =====
  const bgImg=new Image(); bgImg.src="background.jpg";
  const stars=[]; let starFade=1;
  function seedStars(){stars.length=0;const c=Math.floor(canvas.clientWidth*canvas.clientHeight/18000)+40;for(let i=0;i<c;i++){stars.push({x:Math.random()*canvas.clientWidth,y:Math.random()*canvas.clientHeight*0.7,r:Math.random()*1.6+0.6,base:Math.random()*0.35+0.2,amp:Math.random()*0.45+0.25,spd:Math.random()*0.8+0.6,ph:Math.random()*6.283})}}
  seedStars(); addEventListener('resize',seedStars);
  const atmospherePulse=()=>{const t=STATE.t||0,cx=canvas.clientWidth*0.55,cy=canvas.clientHeight*0.52,outer=canvas.clientHeight*(0.65+0.05*Math.sin(t*0.7));ctx.save();const g=ctx.createRadialGradient(cx,cy,20,cx,cy,outer);g.addColorStop(0,'rgba(40,80,100,0.06)');g.addColorStop(1,'rgba(0,0,0,0)');ctx.globalCompositeOperation='lighter';ctx.fillStyle=g;ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);ctx.restore()};

  // ===== particles =====
  const particles=[];
  class Particle{constructor(x,y,dx,dy,life,clr,glow=[255,255,255],size=2,grav=0){this.x=x;this.y=y;this.dx=dx;this.dy=dy;this.life=life;this.max=life;this.clr=clr;this.glow=glow;this.size=size;this.grav=grav}update(dt){this.life-=dt;this.x+=this.dx*dt;this.y+=this.dy*dt;this.dy+=this.grav*dt}draw(ctx){if(this.life<=0)return;const a=Math.max(0,this.life/this.max);glowCircle(ctx,this.x,this.y,this.size*3,a*0.5,0,[...this.glow]);ctx.fillStyle=`rgba(${this.clr[0]},${this.clr[1]},${this.clr[2]},${a})`;ctx.beginPath();ctx.arc(this.x,this.y,this.size,0,Math.PI*2);ctx.fill()}}

  // ===== entities =====
  class Entity{constructor(kind){this.kind=kind;this.alive=true}update(){}draw(){}getCircle(){return{x:0,y:0,r:0}}}
  class Orb extends Entity{constructor(){super('orb');this.r=8+Math.random()*10;this.x=Math.random()*canvas.clientWidth;this.y=10+Math.random()*(canvas.clientHeight*.4);this.vx=(Math.random()*2-1)*40;this.vy=(Math.random()*2-1)*20;this.t=Math.random()*6.28;this.ptimer=0}
    update(dt){this.t+=dt;this.x+=this.vx*dt;this.y+=(Math.sin(this.t*2)*20+this.vy)*dt;if(this.x<this.r){this.x=this.r;this.vx*=-1}if(this.x>canvas.clientWidth-this.r){this.x=canvas.clientWidth-this.r;this.vx*=-1}this.y=clamp(this.y,this.r+6,canvas.clientHeight*.5);this.ptimer-=dt;if(this.ptimer<=0&&(!REDUCED_MOTION||Math.random()<0.6)){this.ptimer=0.04;particles.push(new Particle(this.x+rand(-1,1),this.y+rand(-1,1),rand(-6,6),rand(-6,6),0.5,[220,245,255],[140,220,255],1.7))}}
    draw(ctx){glowCircle(ctx,this.x,this.y,this.r*2.2,.85,0,[140,220,255]);ctx.fillStyle='rgba(240,255,255,.95)';ctx.beginPath();ctx.arc(this.x,this.y,this.r,0,Math.PI*2);ctx.fill();ctx.fillStyle='rgba(255,255,255,.9)';ctx.beginPath();ctx.arc(this.x-this.r*.35,this.y-this.r*.4,this.r*.35,0,Math.PI*2);ctx.fill()}getCircle(){return{x:this.x,y:this.y,r:this.r}}}
  class Drone extends Entity{constructor(){super('drone');this.w=34;this.h=16;this.r=16;this.x=Math.random()*canvas.clientWidth;this.y=canvas.clientHeight*.2+Math.random()*canvas.clientHeight*.3;const s=50+Math.random()*60;this.vx=(Math.random()<.5?-1:1)*s;this.t=Math.random()*6.28}
    update(dt){this.t+=dt;this.x+=this.vx*dt;this.y+=Math.sin(this.t*3)*10*dt;if(this.x<0){this.x=0;this.vx*=-1}if(this.x>canvas.clientWidth){this.x=canvas.clientWidth;this.vx*=-1}this.y=clamp(this.y,canvas.clientHeight*.18,canvas.clientHeight*.55)}
    draw(ctx){const p=1+.25*Math.sin(this.t*6);glowCircle(ctx,this.x,this.y,this.r*1.8*p,.35,0,[255,60,60]);ctx.save();ctx.translate(this.x,this.y);ctx.fillStyle='#9aa9b6';ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);ctx.fillStyle='#233649';ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();const b=Math.sin(this.t*8)>0?'rgba(160,200,255,.9)':'rgba(255,255,255,.4)';ctx.fillStyle=b;ctx.fillRect(-this.w/2+4,-this.h/2+2,4,3);ctx.fillRect(this.w/2-8,-this.h/2+2,4,3);ctx.restore()}getCircle(){return{x:this.x,y:this.y,r:this.r}}}
  const entities=[];

  // ===== player & Captain =====
  const player={
    x:100,y:0,w:34,h:64,speed:260,
    get feetY(){return canvas.clientHeight-36},
    hand:{x:0,y:0}
  };

  // simple 2-bone IK for the aiming (LEFT) arm
  function solveArm(shoulderX,shoulderY,targetX,targetY,upper=16,fore=16,bend=0.26){
    const dx=targetX-shoulderX, dy=targetY-shoulderY;
    let d=Math.hypot(dx,dy); const maxLen=upper+fore;
    const ux = d>1e-4 ? dx/d : 1, uy = d>1e-4 ? dy/d : 0;
    const perpX=-uy, perpY=ux;
    d=Math.min(d,maxLen-0.5);
    const bendAmt = bend*(1 - d/maxLen);
    const elbowX = shoulderX + ux*upper + perpX*upper*bendAmt;
    const elbowY = shoulderY + uy*upper + perpY*upper*bendAmt;
    const handX  = shoulderX + ux*d;
    const handY  = shoulderY + uy*d;
    return {elbowX,elbowY,handX,handY};
  }

  function drawPlayer(){
    const torsoX=player.x, torsoY=player.y;

    // legs
    ctx.save();
    ctx.translate(torsoX,torsoY);
    ctx.fillStyle='#4b6da0';
    ctx.fillRect(6,player.h-18,8,18);
    ctx.fillRect(player.w-14,player.h-18,8,18);

    // torso
    ctx.fillStyle='#6ea3ff';
    ctx.fillRect(2,14,player.w-4,player.h-26);

    // head
    ctx.fillStyle='#e8c39e';
    ctx.beginPath(); ctx.arc(player.w/2,6,12,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#0b0f14'; ctx.fillRect(player.w/2-6,4,3,3); ctx.fillRect(player.w/2+3,4,3,3);

    // shoulder anchors: LEFT (aiming), RIGHT (stationary at outer side)
    const leftSx  = player.w*0.28, leftSy  = 22;  // LEFT aims
    const rightSx = player.w*0.88, rightSy = 22;  // RIGHT sits at the very right side

    // LEFT ARM (aiming)
    const tgtX = input.pointer.x, tgtY = input.pointer.y;
    const worldLSx = torsoX+leftSx, worldLSy = torsoY+leftSy;
    const arm = solveArm(worldLSx,worldLSy,tgtX,tgtY,17,17,0.30);
    player.hand.x = arm.handX; player.hand.y = arm.handY;

    ctx.lineCap='round';
    ctx.strokeStyle='#e8c39e'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(leftSx,leftSy); ctx.lineTo(arm.elbowX-torsoX,arm.elbowY-torsoY); ctx.lineTo(arm.handX-torsoX,arm.handY-torsoY); ctx.stroke();
    ctx.strokeStyle='#cfae82'; ctx.lineWidth=3.5;
    ctx.beginPath(); ctx.moveTo(leftSx,leftSy); ctx.lineTo(arm.elbowX-torsoX,arm.elbowY-torsoY); ctx.lineTo(arm.handX-torsoX,arm.handY-torsoY); ctx.stroke();

    // RIGHT ARM (stationary at outer side — relaxed, slight bend)
    const elbowRx = rightSx + 1;         
    const elbowRy = rightSy + 14;
    const handRx  = rightSx + 1;
    const handRy  = rightSy + 30;

    ctx.strokeStyle='#e8c39e'; ctx.lineWidth=6;
    ctx.beginPath(); ctx.moveTo(rightSx,rightSy); ctx.lineTo(elbowRx,elbowRy); ctx.lineTo(handRx,handRy); ctx.stroke();
    ctx.strokeStyle='#cfae82'; ctx.lineWidth=3.5;
    ctx.beginPath(); ctx.moveTo(rightSx,rightSy); ctx.lineTo(elbowRx,elbowRy); ctx.lineTo(handRx,handRy); ctx.stroke();

    ctx.restore();
  }

  const captain={x:80,y:0,w:36,h:22,dir:1,t:0,cooldown:0,bark:0,get groundY(){return canvas.clientHeight-40},
    reset(){this.x=Math.random()*canvas.clientWidth*.8+20;this.dir=Math.random()<.5?-1:1;this.t=0;this.cooldown=0;this.bark=0},
    update(dt,panic=false){this.t+=dt;this.cooldown=Math.max(0,this.cooldown-dt);this.bark=Math.max(0,this.bark-dt);
      const base=(panic?300:220)*(.85+.3*Math.sin(this.t*3)); this.x+=this.dir*base*dt;
      if(this.x<10){this.x=10;this.dir=1} if(this.x>canvas.clientWidth-10){this.x=canvas.clientWidth-10;this.dir=-1}
      if(panic && Math.random()<0.02) this.dir*=-1;
      this.y=this.groundY-Math.abs(Math.sin(this.t*12))*(panic?10:6)},
    draw(ctx){ctx.save();ctx.translate(this.x,this.y);ctx.scale(this.dir,1);ctx.fillStyle='#8b5f3f';ctx.fillRect(-this.w/2,-this.h/2,this.w,this.h);ctx.beginPath();ctx.arc(this.w/2,-this.h*.2,10,0,Math.PI*2);ctx.fill();ctx.fillStyle='#6d4a2e';ctx.fillRect(this.w/2-3,-this.h*.2-12,6,10);ctx.fillStyle='#10161d';ctx.beginPath();ctx.arc(this.w/2+2,-this.h*.2-2,2,0,Math.PI*2);ctx.fill();ctx.fillRect(this.w/2+6,-this.h*.2+1,3,3);ctx.strokeStyle='#6d4a2e';ctx.lineWidth=3;ctx.beginPath();ctx.moveTo(-this.w/2,-2);ctx.lineTo(-this.w/2-6,-6+Math.sin(this.t*12)*4);ctx.stroke();if(this.bark>0){ctx.fillStyle='#ffd27a';ctx.font='bold 12px Arial';ctx.fillText('WOOF!',-6,-this.h/2-8)}ctx.restore()},
    circle(){return{x:this.x,y:this.y-6,r:14}}};

  // ===== whispers & win verses =====
  const WHISPER_GOOD=["Holy watchers stand","Watchers of heaven","Luminaries keep their order","Stars sing together","He counts the stars","The heavens declare","Messengers of Light","Scribe of righteousness","Hosts of heaven praise","Ministering spirits","Sent forth to serve","Lights for signs","Names in heaven","Morning stars rejoice","Obedient stars","Keepers of truth"];
  const WIN_GOOD=["A watcher, a holy one","The heavens declare His glory","He numbers the stars by name","The morning stars sang together","Ministering spirits sent to serve","Luminaries do not transgress their order","Hosts of heaven worship Him","Signs in the heavens for seasons","Those who are wise shine","Let the righteous be glad"];

  // ===== comet watchers =====
  const watchers=[];
  function spawnWatcher(){if(STATE.mode!=='play')return;const baseP=0.004*(REDUCED_MOTION?0.5:1);if(Math.random()<baseP){const L=Math.random()<.5,y=rand(20,canvas.clientHeight*0.45);let vx=(rand(300,520))*(L?1:-1),vy=rand(40,90),life=rand(0.9,1.5);const hasText=Math.random()<0.25,text=WHISPER_GOOD[(Math.random()*WHISPER_GOOD.length)|0];if(hasText){const s=.55;vx*=s;vy*=s*.8;life*=1.5}watchers.push({x:L?-40:canvas.clientWidth+40,y,vx,vy,life,max:life,phase:Math.random()*6.283,phaseSpd:rand(1.0,1.8),warmth:Math.random()<.35?1:0,hasText,text})}}
  function updateWatchers(dt){if(STATE.mode!=='play')return;for(let i=watchers.length-1;i>=0;i--){const w=watchers[i];w.life-=dt;w.x+=w.vx*dt;w.y+=w.vy*dt;w.phase+=w.phaseSpd*dt;if(!REDUCED_MOTION||Math.random()<.6){particles.push(new Particle(w.x,w.y,-w.vx*0.02+rand(-10,10),-w.vy*0.02+rand(-6,6),0.22,[230,240,255],[200,220,255],1.3))}if(w.life<=0||w.y>canvas.clientHeight*0.6||w.x<-80||w.x>canvas.clientWidth+80)watchers.splice(i,1)}}
  function drawWatchers(){if(STATE.mode!=='play')return;const cool=[200,230,255],warm=[255,210,160];ctx.save();ctx.globalCompositeOperation='lighter';ctx.lineCap='round';for(const w of watchers){const t=1-(w.life/w.max),b=0.7+0.3*Math.sin(w.phase*2),alpha=Math.max(0,Math.sin(Math.PI*t))*0.85*b,mix=w.warmth?Math.pow(t,.7):0.1*t,col=lerpColor(cool,warm,Math.min(1,mix)),rgba=`rgba(${col[0]},${col[1]},${col[2]},${alpha.toFixed(3)})`;ctx.strokeStyle=rgba;ctx.lineWidth=2;ctx.beginPath();ctx.moveTo(w.x,w.y);ctx.lineTo(w.x-w.vx*0.05,w.y-w.vy*0.05);ctx.stroke();ctx.globalAlpha=alpha*0.9;ctx.fillStyle=`rgba(${col[0]},${col[1]},${col[2]},1)`;ctx.beginPath();ctx.arc(w.x,w.y,1.4,0,Math.PI*2);ctx.fill();ctx.globalAlpha=1;if(w.hasText){const ta=Math.min(0.75,Math.sin(Math.PI*t)*0.8);ctx.save();ctx.globalAlpha=ta;ctx.shadowColor=`rgba(${col[0]},${col[1]},${col[2]},0.65)`;ctx.shadowBlur=10;ctx.font=`${Math.round(12+4*t)}px Arial`;ctx.fillStyle=`rgba(${col[0]},${col[1]},${col[2]},0.95)`;ctx.fillText(w.text,w.x-w.vx*0.04+6,w.y-w.vy*0.04-2);ctx.restore()}}ctx.restore()}

  // ===== spawns & collisions =====
  let spawnTimer=0;
  const spawn=(dt)=>{spawnTimer-=dt;if(spawnTimer<=0&&STATE.mode==='play'){entities.push(Math.random()<SETTINGS.droneChance?new Drone():new Orb());if(entities.length>SETTINGS.max)entities.shift();spawnTimer=.6+Math.random()*.6}};
  const lineHitsCircle=(x1,y1,x2,y2,cx,cy,r)=>{const vx=x2-x1,vy=y2-y1,wx=cx-x1,wy=cy-y1,v2=vx*vx+vy*vy||1e-6,t=Math.max(0,Math.min(1,(wx*vx+wy*vy)/v2)),px=x1+t*vx,py=y1+t*vy,dx=px-cx,dy=py-cy;return dx*dx+dy*dy<=r*r};
  let laserCD=0, laserSparkTimer=0;

  // ===== flow =====
  function startGame(){try{audio().resume()}catch{} STATE.running=true;STATE.paused=false;STATE.ended=false;STATE.mode='play';STATE.timeLeft=SETTINGS.timeStart;STATE.score=0;STATE.hits=0;STATE.misses=0;STATE.streak=0;entities.length=0;particles.length=0;watchers.length=0;spawnTimer=0;player.x=(canvas.clientWidth - player.w)/2;player.y=player.feetY-player.h;captain.reset();titleEl.style.display='none';pauseBtn.disabled=false;resetBtn.disabled=false;overlay.style.display='none';versesBox.innerHTML='';againBtn.style.display='none';titleText.textContent='ENOCH';hintEl.textContent='Tap or press any key to continue…';starFade=1}
  function togglePause(){if(!STATE.running||STATE.mode!=='play')return;STATE.paused=!STATE.paused;pauseBtn.textContent=STATE.paused?'Resume':'Pause'}
  function resetGame(){STATE.running=false;STATE.paused=false;STATE.ended=false;STATE.mode='play';titleEl.style.display='flex';pauseBtn.disabled=true;resetBtn.disabled=true;pauseBtn.textContent='Pause';overlay.style.display='none';versesBox.innerHTML='';againBtn.style.display='none';overlayCenter.classList.remove('topRight');starFade=1}
  startBtn.addEventListener('click',()=>{if(!STATE.running)startGame()}); tPlay.addEventListener('click',()=>{if(!STATE.running)startGame()});
  pauseBtn.addEventListener('click',togglePause); resetBtn.addEventListener('click',resetGame);

  function update(dt){
    STATE.t += dt;
    if(!STATE.running || STATE.paused) return;

    if(STATE.mode==='play'){
      STATE.timeLeft=Math.max(0,STATE.timeLeft-dt);
      if(STATE.timeLeft===0){
        STATE.ended=true;
        if(STATE.score>=SETTINGS.goal){ startWinCinematic(); }
        else { startLoseCinematic(); }
        return;
      }
      // movement
      player.y=player.feetY-player.h;
      // Lock player horizontally at center (no left/right movement)
      player.x = (canvas.clientWidth - player.w) / 2;

      // spawns / updates
      spawn(dt);
      entities.forEach(e=>e.update(dt));
      captain.update(dt,false);

      // particles update
      for(let i=particles.length-1;i>=0;i--){const p=particles[i];p.update(dt);if(p.life<=0)particles.splice(i,1)}

      // watchers
      spawnWatcher();
      updateWatchers(dt);

      // laser interactions
      laserCD=Math.max(0,laserCD-dt);
      laserSparkTimer-=dt;
      if(input.aiming){
        // LEFT-hand IK origin
        const shoulderX = player.x + player.w*0.28;
        const shoulderY = player.y + 22;
        const ik = solveArm(shoulderX,shoulderY,input.pointer.x,input.pointer.y,17,17,0.30);
        player.hand.x = ik.handX; player.hand.y = ik.handY;

        const sx=player.hand.x, sy=player.hand.y, tx=input.pointer.x, ty=input.pointer.y;

        if(!REDUCED_MOTION || Math.random()<0.5){ particles.push(new Particle(sx,sy,rand(-10,10),rand(-10,10),0.08,[140,255,200],[0,255,120],1.4)); }
        if(laserSparkTimer<=0){
          laserSparkTimer = REDUCED_MOTION ? 0.04 : 0.025;
          const steps = REDUCED_MOTION ? 3 : 6;
          for(let i=1;i<=steps;i++){ const t=i/(steps+1); const lx=sx+(tx-sx)*t + rand(-1.2,1.2); const ly=sy+(ty-sy)*t + rand(-1.2,1.2); particles.push(new Particle(lx,ly,0,0,0.12,[120,255,200],[0,255,120],1.2)); }
        }
        const cap=captain.circle();
        if(lineHitsCircle(sx,sy,tx,ty,cap.x,cap.y,cap.r) && captain.cooldown<=0){captain.bark=.5;captain.cooldown=.6;sfx.bark()}
        let best=null,bestD2=Infinity;
        for(const e of entities){ if(!e.alive)continue; const c=e.getCircle(); if(lineHitsCircle(sx,sy,tx,ty,c.x,c.y,c.r)){ const dx=c.x-sx,dy=c.y-sy,d2=dx*dx+dy*dy; if(d2<bestD2){best=e;bestD2=d2} } }
        if(laserCD<=0 && best){
          const hitC=best.getCircle();
          for(let i=0;i<14;i++){ const ang=Math.random()*Math.PI*2, spd=rand(100,200); const color = best.kind==='orb' ? [190,255,255] : [255,140,120]; const glow  = best.kind==='orb' ? [140,220,255] : [255,60,60]; particles.push(new Particle(hitC.x,hitC.y,Math.cos(ang)*spd,Math.sin(ang)*spd,0.35,color,glow,1.8)); }
          for(let i=0;i<10;i++){ const ang=Math.random()*Math.PI*2, spd=rand(20,60); const color = best.kind==='orb' ? [200,250,255] : [255,180,140]; const glow  = best.kind==='orb' ? [160,220,255] : [255,100,80]; particles.push(new Particle(hitC.x,hitC.y,Math.cos(ang)*spd,Math.sin(ang)*spd,0.9,color,glow,1.3,28)); }
          if(best.kind==='orb'){ STATE.hits++;STATE.streak++;STATE.score+=100+Math.max(0,STATE.streak-2)*25; best.alive=false; sfx.orb(); }
          else { STATE.misses++;STATE.streak=0;STATE.score-=150; sfx.drone(); captain.bark=.6; sfx.bark(); }
          laserCD=.12;
        }
      }
    }
    else if(STATE.mode==='cin_win'){ updateWinCinematic(dt); }
    else if(STATE.mode==='cin_lose'){ updateLoseCinematic(dt); }
  }

  function drawBackground(){
    ctx.drawImage(bgImg,0,0,canvas.clientWidth,canvas.clientHeight);

    // starfield (scaled by starFade)
    ctx.save(); ctx.globalCompositeOperation='lighter';
    for(const s of stars){
      const ampScale = REDUCED_MOTION ? 0.35 : 1.0;
      const a = (s.base + Math.sin(STATE.t*s.spd + s.ph)*s.amp*ampScale) * starFade;
      ctx.fillStyle=`rgba(255,255,210,${a})`;
      ctx.beginPath(); ctx.arc(s.x,s.y,s.r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    const y=canvas.clientHeight-30; ctx.fillStyle='#0b1f12';ctx.fillRect(0,y,canvas.clientWidth,30);
    ctx.fillStyle='#1b2d1f';for(let x=0;x<canvas.clientWidth;x+=18){ctx.fillRect(x+4,y-18,10,18)}
    ctx.fillStyle='#334a2f';ctx.fillRect(0,y-6,canvas.clientWidth,6);

    atmospherePulse();
  }

  function render(){
    drawBackground();

    if(STATE.mode==='play'){
      drawWatchers();
      entities.forEach(e=>e.draw(ctx));
      drawPlayer(); captain.draw(ctx);

      if(input.aiming){
        const sx=player.hand.x, sy=player.hand.y, tx=input.pointer.x, ty=input.pointer.y;
        ctx.save(); ctx.globalCompositeOperation='lighter';
        // Beam thickness scales with DPR (visibility on phones), no gameplay impact
        const px = Math.max(1, (window.devicePixelRatio||1));
        ctx.strokeStyle='rgba(0,255,120,.85)'; ctx.lineWidth = 2.0 * Math.min(px, 2.5);
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(tx,ty); ctx.stroke();
        ctx.strokeStyle='rgba(120,255,200,.25)'; ctx.lineWidth = 5.0 * Math.min(px, 2.5);
        ctx.beginPath(); ctx.moveTo(sx,sy); ctx.lineTo(tx,ty); ctx.stroke();
        ctx.restore();
      }
      for(const p of particles) p.draw(ctx);

    } else if(STATE.mode==='cin_win'){
      drawWinCinematic();
    } else if(STATE.mode==='cin_lose'){
      drawLoseCinematic();
    }

    // HUD
    scoreEl.textContent=STATE.score;
    timeEl.textContent=STATE.timeLeft.toFixed(1);
    hitsEl.textContent=STATE.hits;
    missesEl.textContent=STATE.misses;
  }

  function loop(t){const n=t||performance.now(),dt=Math.min(.033,(n-(STATE.last||n))/1000);STATE.last=n;update(dt);render();requestAnimationFrame(loop)}
  requestAnimationFrame(loop);

  // show start
  titleEl.style.display='flex';

  // ===== WIN CINEMATIC =====
  let cinWin=null;

  function startWinCinematic(){
    overlayCenter.classList.remove('topRight');
    sfx.win();
    STATE.mode='cin_win';
    overlay.style.display='block';
    bindSkip();

    const area = canvas.clientWidth*canvas.clientHeight;
    const baseCap = Math.floor(area/6500);
    const DOT_LIMIT = REDUCED_MOTION ? Math.min(320, Math.max(220, baseCap)) :
                      Math.min(1200, Math.max(500, baseCap));

    const droneCount = REDUCED_MOTION ? 5 : 9;
    const drones=[];
    for(let i=0;i<droneCount;i++){
      drones.push({ x: rand(20, canvas.clientWidth-20), y: rand(canvas.clientHeight*0.18, canvas.clientHeight*0.5), vy: rand(-120,-200), alpha: 1 });
    }

    const orbStarts = [];
    for(const e of entities){ if(e.kind==='orb') orbStarts.push({x:e.x,y:e.y}); }
    entities.length=0; watchers.length=0; particles.length=0;

    const built = buildEnochTargets(DOT_LIMIT);
    const targets = built.points;
    const sources = shuffle(orbStarts).slice(0, targets.length);
    const need = Math.max(0, targets.length - sources.length);
    for(let i=0;i<need;i++){
      sources.push({x:rand(10,canvas.clientWidth-10), y:rand(10,canvas.clientHeight*0.5)});
    }

    const shuffledTargets = shuffle(targets);
    const dots=[];
    for(let i=0;i<shuffledTargets.length;i++){
      const s=sources[i], t=shuffledTargets[i];
      const dur = REDUCED_MOTION ? rand(1.0,1.5) : rand(1.4,2.2);
      dots.push({x:s.x,y:s.y, tx:t.x,ty:t.y, t:0,dur, edge:t.edge});
    }

    const WIN_GOOD=["A watcher, a holy one","The heavens declare His glory","He numbers the stars by name","The morning stars sang together","Ministering spirits sent to serve","Luminaries do not transgress their order","Hosts of heaven worship Him","Signs in the heavens for seasons","Those who are wise shine","Let the righteous be glad"];
    const versesThisRun = randomSubset(WIN_GOOD, REDUCED_MOTION ? 3 : 4);
    versesBox.innerHTML=''; titleText.textContent='ENOCH'; hintEl.textContent='Tap or press any key to continue…'; againBtn.style.display='none';

    cinWin = {
      t:0, phase:0, done:false, fastForward:false,
      drones, dots, verses:versesThisRun,
      showVerseIdx:-1, verseTimer:0.25, holdTimer:0.8,
      breathe:0,
      meta: built.meta
    };
  }

  function buildEnochTargets(maxPts){
    const off=document.createElement('canvas'), w=720,h=720; off.width=w; off.height=h; const oc=off.getContext('2d');
    oc.clearRect(0,0,w,h); oc.fillStyle='#fff';
    const cx=w/2, base=h-22;

    oc.beginPath();
    oc.moveTo(cx-56, 276);
    oc.quadraticCurveTo(cx-20, 260, cx, 260);
    oc.quadraticCurveTo(cx+20, 260, cx+56, 276);
    oc.bezierCurveTo(cx+152, 340, cx+180, 520, cx+180, base);
    oc.lineTo(cx-180, base);
    oc.bezierCurveTo(cx-180, 520, cx-152, 340, cx-56, 276);
    oc.closePath(); oc.fill();

    oc.beginPath();
    oc.moveTo(cx, 128);
    oc.bezierCurveTo(cx-62, 148, cx-70, 198, cx-45, 230);
    oc.bezierCurveTo(cx-22, 246, cx-10, 252, cx, 254);
    oc.bezierCurveTo(cx+10, 252, cx+22, 246, cx+45, 230);
    oc.bezierCurveTo(cx+70, 198, cx+62, 148, cx, 128);
    oc.closePath(); oc.fill();

    oc.beginPath(); oc.moveTo(cx-18, 248); oc.lineTo(cx+18, 248); oc.lineTo(cx, 304); oc.closePath(); oc.fill();
    oc.beginPath(); oc.ellipse(cx, 244, 28, 18, 0, 0, Math.PI*2); oc.fill();

    oc.beginPath(); oc.moveTo(cx-48, 300); oc.bezierCurveTo(cx-150, 350, cx-150, 410, cx-70, 430); oc.lineTo(cx-48, 420); oc.closePath(); oc.fill();
    oc.beginPath(); oc.moveTo(cx+48, 300); oc.bezierCurveTo(cx+150, 350, cx+150, 410, cx+70, 430); oc.lineTo(cx+48, 420); oc.closePath(); oc.fill();

    oc.fillRect(cx-82, 408, 164, 18);

    const staffTopY=258, staffBaseY=base+10, staffX=cx+146;
    oc.fillRect(staffX-8, staffTopY, 16, staffBaseY-staffTopY);
    oc.beginPath(); oc.arc(staffX, staffTopY-22, 20, 0, Math.PI*2); oc.fill();
    const rawStaffTip={x:staffX, y:staffTopY-22};

    oc.save(); oc.translate(cx-126, 332); oc.rotate(-0.22); oc.fillRect(-52,-16,104,32); oc.restore();

    oc.globalCompositeOperation='destination-out';
    oc.beginPath(); oc.moveTo(cx, base-2); oc.lineTo(cx-12, base-62); oc.lineTo(cx+12, base-62); oc.closePath(); oc.fill();
    oc.beginPath(); oc.ellipse(cx, 360, 44, 7, 0, 0, Math.PI*2); oc.fill();
    oc.beginPath(); oc.ellipse(cx, 288, 20, 6, 0, 0, Math.PI*2); oc.fill();
    oc.globalCompositeOperation='source-over';

    const stepBase=10, step=REDUCED_MOTION?stepBase+3:stepBase;
    const edges=[], fills=[];
    const img=oc.getImageData(0,0,w,h).data;
    const aAt=(x,y)=> (x<0||y<0||x>=w||y>=h)?0:img[(y*w+x)*4+3];
    for(let y=0;y<h;y+=step){
      for(let x=0;x<w;x+=step){
        const a=aAt(x,y);
        if(a>160){
          const e=aAt(x+step,y)<100||aAt(x-step,y)<100||aAt(x,y+step)<100||aAt(x,y-step)<100;
          const jitter = e ? 0 : (Math.random()-0.5)*step*0.35;
          (e?edges:fills).push({x:x+jitter,y:y-jitter,edge:e});
        }
      }
    }
    const edgeRatio = 0.70;
    const wantEdges=Math.min(edges.length,Math.floor(maxPts*edgeRatio));
    const wantFill=Math.min(fills.length,Math.max(0,maxPts-wantEdges));
    const chosen=shuffle(edges).slice(0,wantEdges).concat(shuffle(fills).slice(0,wantFill));

    const scale=(canvas.clientHeight*0.54)/h;
    const ox=canvas.clientWidth*0.5-(w*scale)/2;
    const oy=Math.max(6, canvas.clientHeight*0.02);

    let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
    for(const p of chosen){p.x=ox+p.x*scale;p.y=oy+p.y*scale; if(p.x<minX)minX=p.x; if(p.y<minY)minY=p.y; if(p.x>maxX)maxX=p.x; if(p.y>maxY)maxY=p.y; }

    const staffTip = { x: ox + rawStaffTip.x*scale, y: oy + rawStaffTip.y*scale };
    const center = { x:(minX+maxX)/2, y:(minY+maxY)/2 };
    const radius = Math.max(maxX-minX, maxY-minY)/2;

    return { points: chosen, meta:{staffTip, center, radius} };
  }

  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=(Math.random()*(i+1))|0;[a[i],a[j]]=[a[j]]}return a}
  function randomSubset(arr,n){const s=shuffle([...arr]);return s.slice(0,Math.max(0,Math.min(n,s.length)))}

  function updateWinCinematic(dt){
    if(!cinWin) return;
    const C=cinWin; C.t+=dt;

    if(C.fastForward){
      C.drones.length=0;
      C.dots.forEach(d=>{d.x=d.tx; d.y=d.ty; d.t=d.dur;});
      C.phase=1; C.holdTimer=0.15; C.fastForward=false;
    }

    if(C.phase===0){
      for(let i=C.drones.length-1;i>=0;i--){
        const d=C.drones[i]; d.y+=d.vy*dt; d.alpha=Math.max(0,d.alpha-dt*0.7);
        if(d.y<-40||d.alpha<=0) C.drones.splice(i,1);
      }
      for(const d of C.dots){
        d.t=Math.min(d.dur,d.t+dt);
        const k=easeInOut(d.t/d.dur);
        d.x=lerp(d.x,d.tx,k); d.y=lerp(d.y,d.ty,k);
      }
      const allIn=C.dots.every(d=>d.t>=d.dur*0.98);
      if((C.drones.length===0 && allIn) || C.t>4.8){ C.phase=1; C.t=0; }
    } else if(C.phase===1){
      C.holdTimer-=dt; if(C.holdTimer<=0){ C.phase=2; C.t=0; C.showVerseIdx=-1; C.verseTimer=0.25; versesBox.innerHTML=''; }
    } else if(C.phase===2){
      C.verseTimer-=dt;
      if(C.verseTimer<=0){
        C.showVerseIdx++;
        if(C.showVerseIdx < C.verses.length){
          addLine('“'+C.verses[C.showVerseIdx]+'”');
          C.verseTimer = REDUCED_MOTION ? 2.0 : 2.6;
        }else{
          againBtn.style.display='inline-block';
          againBtn.onclick=()=>{ resetGame(); };
          C.done=true;
        }
      }
    }
  }

  function drawWinCinematic(){
    if(!cinWin) return; const C=cinWin;

    // halo
    if(C.meta){
      const r=C.meta.radius*1.35, a=0.10+0.05*Math.sin(C.t*1.4);
      const {x,y}=C.meta.center;
      ctx.save();
      const g=ctx.createRadialGradient(x,y,r*0.25,x,y,r);
      g.addColorStop(0,`rgba(180,220,255,${0.10+a})`);
      g.addColorStop(1,'rgba(0,0,0,0)');
      ctx.globalCompositeOperation='lighter';
      ctx.fillStyle=g; ctx.fillRect(0,0,canvas.clientWidth,canvas.clientHeight);
      ctx.restore();
    }

    // dots
    const pulse = 0.24 + 0.10*Math.sin(C.t*1.2);
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.fillStyle='rgba(235,250,255,0.95)'; ctx.beginPath();
    for(const d of C.dots){ ctx.moveTo(d.x+1.5,d.y); ctx.arc(d.x,d.y,d.edge?1.9:1.5,0,Math.PI*2); }
    ctx.fill();
    for(const d of C.dots){ glowCircle(ctx,d.x,d.y,d.edge?7.0:5.4,0.62+pulse,0,[140,220,255]); }
    ctx.restore();

    // staff tip twinkle
    if(C.meta && C.meta.staffTip){
      const s=C.meta.staffTip, tw=1+0.6*Math.sin(C.t*8);
      glowCircle(ctx,s.x,s.y,9+tw*2,0.8,0,[180,230,255]);
      ctx.save(); ctx.globalCompositeOperation='lighter';
      ctx.strokeStyle='rgba(200,240,255,0.9)';
      ctx.lineWidth=1.4;
      ctx.beginPath(); ctx.moveTo(s.x-6,s.y); ctx.lineTo(s.x+6,s.y);
      ctx.moveTo(s.x,s.y-6); ctx.lineTo(s.x,s.y+6); ctx.stroke();
      ctx.restore();
    }

    overlay.style.pointerEvents='none'; overlay.style.display='block';
    titleText.textContent='ENOCH';
  }

  // ===== LOSE CINEMATIC =====
  let cinLose=null;

  function startLoseCinematic(){
    overlayCenter.classList.add('topRight');
    sfx.lose();
    STATE.mode='cin_lose';
    overlay.style.display='none';
    versesBox.innerHTML='';
    againBtn.style.display='none';
    starFade = 1;

    const cx = player.x + player.w/2, cy = player.y + player.h/2;
    const count = REDUCED_MOTION ? 4 : 6;
    const radius = Math.min(160, canvas.clientWidth*0.22);
    const drones=[];
    for(let i=0;i<count;i++){
      const a = (i/count)*Math.PI*2 + Math.random()*0.4;
      const tx = cx + Math.cos(a)*radius;
      const ty = cy - 40 + Math.sin(a)*(radius*0.6);
      drones.push({
        x: rand(0,canvas.clientWidth), y: -40-rand(0,100),
        tx, ty,
        t: 0, dur: rand(1.0,1.6), bob: rand(0,Math.PI*2)
      });
    }

    const ground = canvas.clientHeight-36;
    const agentY = ground-60;
    const agents = [
      {x:-60, y:agentY, dir:1, target:{x: cx-26, y: agentY}, phase:'in', speed:140},
      {x:canvas.clientWidth+60, y:agentY, dir:-1, target:{x: cx+26, y: agentY}, phase:'in', speed:140}
    ];

    cinLose = { t:0, phase:0, drones, agents, target:{x:cx,y:cy}, escortSpeed:160, barkTimer:0, done:false };
  }

  function updateLoseCinematic(dt){
    if(!cinLose) return;
    const L=cinLose; L.t += dt;

    starFade = Math.max(0, starFade - dt*0.8);

    for(const d of L.drones){
      d.t = Math.min(d.dur, d.t + dt);
      const k = easeInOut(d.t/d.dur);
      d.x = lerp(d.x, d.tx, k);
      d.y = lerp(d.y, d.ty, k);
      d.bob += dt*2.2;
    }

    let bothAtSides = true;
    for(const a of L.agents){
      if(a.phase==='in'){
        const dx = a.target.x - a.x;
        if(Math.abs(dx) > 2) { a.x += Math.sign(dx)*a.speed*dt; bothAtSides = false; }
        else { a.x = a.target.x; }
      }
    }

    cinLose.barkTimer = (cinLose.barkTimer||0) - dt;
    captain.update(dt,true);
    if(cinLose.barkTimer<=0){
      captain.bark = 0.5;
      sfx.bark();
      cinLose.barkTimer = 0.9;
    }

    if(L.phase===0 && bothAtSides){ L.phase=1; L.hold=0.6; }
    if(L.phase===1){ L.hold -= dt; if(L.hold<=0){ L.phase=2; } }
    if(L.phase===2){
      const exitX = canvas.clientWidth + 120;
      player.x += L.escortSpeed*dt;
      for(const a of L.agents){ a.x += L.escortSpeed*dt; }
      L.target.x = player.x + player.w/2;
      L.target.y = player.y + player.h/2;
      if(player.x > exitX){
        L.phase=3;
        titleText.textContent='SPOTTED';
        hintEl.textContent='Tap or press any key…';
        versesBox.innerHTML='';
        addLine('The drones marked you.');
        addLine('Agents escorted you away.');
        againBtn.style.display='inline-block';
        againBtn.onclick=()=>resetGame();
        overlay.style.display='block';
        L.done=true;
      }
    }
  }

  function drawDronePointer(d, target){
    const r=16;
    const bobY = Math.sin(d.bob)*2.5;
    const x=d.x, y=d.y + bobY;
    glowCircle(ctx,x,y,r*1.8,0.35,0,[255,60,60]);
    ctx.save(); ctx.translate(x,y);
    ctx.fillStyle='#9aa9b6';ctx.fillRect(-17,-8,34,16);
    ctx.fillStyle='#233649';ctx.beginPath();ctx.arc(0,0,4,0,Math.PI*2);ctx.fill();
    ctx.restore();
    ctx.save(); ctx.globalCompositeOperation='lighter';
    ctx.strokeStyle='rgba(255,80,80,0.9)'; ctx.lineWidth=1.8;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(target.x,target.y); ctx.stroke();
    ctx.strokeStyle='rgba(255,40,40,0.35)'; ctx.lineWidth=5.5;
    ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(target.x,target.y); ctx.stroke();
    ctx.restore();
  }

  function drawAgent(a){
    ctx.save();
    ctx.translate(a.x,a.y);
    ctx.scale(a.dir,1);
    ctx.fillStyle='#0a0d12';
    ctx.fillRect(-14,-60,28,60);
    ctx.fillStyle='#0c1218';
    ctx.fillRect(-14,-60,6,20);
    ctx.fillRect(8,-60,6,20);
    ctx.fillStyle='#a9c6ff';
    ctx.fillRect(-2,-38,4,22);
    ctx.fillStyle='#d2c7b8';
    ctx.beginPath(); ctx.arc(0,-70,10,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#111';
    ctx.fillRect(-10,-74,8,6);
    ctx.fillRect(  2,-74,8,6);
    ctx.fillRect(-2,-72,4,2);
    ctx.fillStyle='#06090d';
    ctx.fillRect(-18,-46,6,22);
    ctx.fillRect( 12,-46,6,22);
    ctx.restore();
  }

  function drawLoseCinematic(){
    if(!cinLose) return;
    const L=cinLose;
    for(const d of L.drones) drawDronePointer(d, L.target);
    drawPlayer();
    for(const a of L.agents) drawAgent(a);
    captain.draw(ctx);
  }

  function addLine(line){const p=document.createElement('p');p.textContent=line;p.style.margin='6px 0';p.style.opacity='0';p.style.transition='opacity 600ms ease';versesBox.appendChild(p);requestAnimationFrame(()=>p.style.opacity='1')}

  // skip-to-final for win overlay
  const bindSkip=()=>{window.addEventListener('keydown',skipOnce,{once:true});window.addEventListener('mousedown',skipOnce,{once:true});window.addEventListener('touchstart',skipOnce,{once:true})};
  const skipOnce=()=>{if(cinWin && !cinWin.done){cinWin.fastForward=true;}}

  titleEl.style.display='flex';
})();
</script>
</body>
</html>
